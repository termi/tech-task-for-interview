'use strict';
import{createAbortError as e}from"../common/abortable";let t;export function eventsAsyncIterator(o,s,i={}){if(null==s)throw new TypeError(`eventsAsyncIterator: Invalid "event" argument. Received ${String(s)}`);const{signal:l,computeValue:a,stopEventName:c,errorEventName:u="error",isDebug:v=!1}=i,f="function"==typeof a,h=!!(m=o)&&"function"==typeof m.addEventListener&&"function"==typeof m.removeEventListener;var m;let y,d=!1,g=0;const p=[],E=[],b=async(e,t)=>{const n=[];if(f){
const r=e=>{n.push(e)};e=await a.call(S,t,e,r)}return{value:e,step1Result:{onAfterComputeValueCallbacks:n}}},w=async e=>{if(!e)return;const{onAfterComputeValueCallbacks:t}=e;if(Array.isArray(t)&&0!==t.length)for(const e of t)if("function"==typeof e)try{await e.call(S)}catch(e){S.throw(e);break}},A=f?async(...e)=>{if(!g){if(E.length>0){const t=E.shift();if(t){try{let n,r=e;if(f){const e=s,{value:t,step1Result:o}=await b(r,e);r=t,n=o}t.resolve({value:r,done:!1}),f&&n&&await w(n)}catch(e){
S.throw(e)}return}}p.push({eventName:s,eventArgs:e})}}:(...e)=>{if(!g){if(E.length>0){const t=E.shift();if(t){const n=e;return void t.resolve({value:n,done:!1})}}p.push({eventName:s,eventArgs:e})}},L=t=>{if(g=t,l&&l.removeEventListener("abort",j),h?(r(o,s,A),null!=c&&r(o,c,I),null!=u&&u!==s&&r(o,u,N)):(o.removeListener(s,A),null!=c&&o.removeListener(c,I),null!=u&&u!==s&&o.removeListener(u,N)),1===t||4===t||2===t)if(1===t){const t=e(void 0,l?l.reason:void 0);let n=!1;if(E.length>0){
const e=E.shift();e&&(e.reject(t),n=!0)}n||(d=!0,y=t)}else if(2===t&&E.length>0){const e=E.shift();if(e){const t=y;d=!1,y=void 0,e.reject(t)}}if(E.length>0){v&&p.length>0&&console.warn("eventsAsyncIterator: logical error: unconsumedEvents should be empty array");const e={value:void 0,done:!0};for(const t of E)t.resolve(e);E.length=0}},I=L.bind(null,3),j=L.bind(null,1),N=e=>{d=!0,y=e,L(2)};h?(n(o,s,A),null!=c&&n(o,c,I),null!=u&&u!==s&&n(o,u,N)):(o.on(s,A),null!=c&&o.on(c,I),
null!=u&&u!==s&&o.on(u,N)),l&&l.addEventListener("abort",j,{once:!0});const S=Object.setPrototypeOf({[Symbol.asyncIterator](){return this},async next(){if(p.length>0){const e=p.shift();if(e){const{eventName:t,eventArgs:n}=e;let r,o=n;if(f){const{value:e,step1Result:n}=await b(o,t);o=e,r=n}const s=Promise.resolve({value:o,done:!1});return f&&r&&await w(r),s}if(v)throw new Error("Invalid state")}if(d){const e=y;throw d=!1,y=void 0,e}return g?{value:void 0,done:!0}:new Promise((e,t)=>{E.push({
resolve:e,reject:t})})},return:e=>(L(4),Promise.resolve({value:e,done:!0})),throw(e){if(!(e&&e instanceof Error))throw new TypeError("eventsAsyncIterator#throw(): Invalid argument",{cause:e});return d=!0,y=e,L(5),this.next()},getDebugInfo(){if(v)return{isDebug:v,unconsumedEvents_length:p.length,unconsumedPromises_length:E.length,finishedState:g,has_iteratorErrorToReject:d,iteratorErrorToReject:y,eventName:s,errorEventName:u,stopEventName:c,has_signal:l}}
},(void 0!==t||(t=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype)),t));return S}function n(e,t,n,r){let o=t;"symbol"!=typeof o||s(e)||(o=String(o)),e.addEventListener(o,n,r)}function r(e,t,n,r){let o=t;"symbol"!=typeof o||s(e)||(o=String(o)),e.removeEventListener(o,n,r)}const o=Symbol("kEventTargetSupportSymbolAsType");function s(e){if(void 0!==e[o])return e[o];let t=!1;const n=()=>{};try{e.addEventListener(o,n),e.removeEventListener(o,n),t=!0}catch{}return e[o]=t,t}
