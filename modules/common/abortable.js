'use strict';
let t="undefined"!=typeof AbortController?AbortController:void 0,e="undefined"!=typeof AbortSignal?AbortSignal:void 0,r="function"==typeof t&&"function"==typeof e,o=r?t:void 0,n=o,i=r,s=!1,a=!1;const c="AbortSignal",l="AbortController",b="AbortError",u="TimeoutError",f="undefined"!=typeof Symbol,h=f&&Symbol.toStringTag,d=(t,e)=>{if(t)if(h){if(t[h]!==e)try{Object.defineProperty(t,h,{value:e,configurable:!0})}catch{}}else t.toString||(t.toString=function(){return`[object ${e}]`})}
;function p(t,e,r=!0,o){return void 0===o?Object.defineProperty(t,e,{enumerable:!1,writable:r,configurable:!0}):Object.defineProperty(t,e,{value:o,enumerable:!1,writable:r,configurable:!0}),t}function v(t){if(!t)return!1;const e=new t;let r=!1;const o=()=>r=!0;return e.signal.addEventListener("abort",o),e.abort(),e.signal.removeEventListener("abort",o),r}if(r&&"undefined"!=typeof window&&"function"==typeof Request&&!Request.prototype.hasOwnProperty("signal")&&(i=!1,v(t)||(o=void 0,n=void 0,
t=void 0,e=void 0,r=!1)),r&&(function(){let e=!1;try{const r=t;class o extends r{test;constructor(){super(),this.test=!0}}e=!0===(new o).test&&v(o)}catch{}e||(s=!0)}(),s||function(){const t=new AbortController,{signal:e}=t,r=Symbol();t.abort(r),e.reason!==r&&(a=!0)}()),!r||s||a){const T=r&&(s||a),P="function"==typeof setImmediate?setImmediate:"function"==typeof queueMicrotask?queueMicrotask:setTimeout;class D{listeners;constructor(){this.listeners=Object.create(null),p(this,"listeners")}
addEventListener(t,e,r={}){const{signal:o}=r;if(void 0!==o&&!isAbortSignal(o))throw new TypeError("Failed to execute 'addEventListener' on 'EventTarget': member signal is not of type AbortSignal.");if(!e)return;this.listeners[t]||(this.listeners[t]=[]);const n=this.listeners[t];if(n.some(({callback:t})=>t===e))return;let i;if(o){if(o.aborted)return;const r=()=>{this.removeEventListener(t,e)};i=function(){o.removeEventListener("abort",r)},o.addEventListener("abort",r,{once:!0})}
const s="object"==typeof r&&r?!!r.once:void 0;n.push({callback:e,once:s,unsubscribeSignalCallback:i})}removeEventListener(t,e){if(!this.listeners[t])return;const r=this.listeners[t],o=r.findIndex(({callback:t})=>t===e);if(-1!==o){const t=r[o],{unsubscribeSignalCallback:e}=t;e&&(e(),t.unsubscribeSignalCallback=void 0),r.splice(o,1)}0===r.length&&delete this.listeners[t]}dispatchEvent(t){const{type:e}=t,r=this.listeners[e];if(!r)return!1;const o=[...r];for(let r=0,n=o.length;r<n;r++){const n=o[r]
;try{n.callback.call(this,t)}catch(t){P(()=>{throw t})}if(n.once){const{unsubscribeSignalCallback:t}=n;t&&(t(),n.unsubscribeSignalCallback=void 0),this.removeEventListener(e,n.callback)}}return!t.defaultPrevented}}let F=!0;const R=f?Symbol("sTrueAbortEvent"):"__sTrueAbortEvent__",I=f?Symbol("sDispatchEvent"):"__sDispatchEvent__",M=class extends D{_aborted=!1;get aborted(){return this._aborted}_reason=void 0;get reason(){return this._reason}onabort=null;constructor(){super(),
this.listeners||D.call(this),p(this,"_aborted"),p(this,"_reason"),p(this,"onabort")}[I](t,e){const r="abort"===t.type&&(!F||!0===t[R]);r&&(this._aborted=!0,this._reason=e);const o=this.dispatchEvent(t);return r&&(this.listeners=Object.create(null)),o}dispatchEvent(t){return"abort"===t.type&&(!F||!0===t[R])&&"function"==typeof this.onabort&&this.onabort.call(this,t),super.dispatchEvent(t)}static abort(t){const e=new G;return e.abort(t),e.signal}}
;M.prototype.constructor.name!==c&&Object.defineProperty(M.prototype.constructor,"name",{value:c,configurable:!0});const N=function(){try{if(new Event("test")instanceof Event)return function(t){return new Event(t)}}catch{}if("undefined"!=typeof document)try{if(document.createEvent){return document.createEvent("Event").initEvent("test",!1,!1),function(t){const e=document.createEvent("Event");return e.initEvent(t,!1,!1),e}}if(document.createEventObject){const t=document.createEventObject()
;if(t.type="abort","abort"===t.type)return function(t){const e=document.createEventObject();return e.type=t,e}}}catch{}return function(t){return{type:t,bubbles:!1,cancelable:!1,defaultPrevented:!1,preventDefault(){this.defaultPrevented=!0}}}}(),q=f?Symbol("kIsAborted2"):"_kIsAborted2",$=T?o:void 0;let G=class{signal;_nativeAC;constructor(){if(p(this,"signal"),$){const t=new $;this._nativeAC=t,this.signal=t.signal}else this.signal=new M}abort(t){if(this[q])return
;if(void 0===t&&(t=createAbortError()),this[q]=!0,this._nativeAC){const{_nativeAC:e}=this;if(a){const{signal:r}=e;Object.defineProperty(r,"reason",{value:t,writable:!1,enumerable:!0,configurable:!0})}return void e.abort(t)}const e=N("abort");if(e[R]=!0,!0!==e[R]&&(F=!1),!(this.signal instanceof M))throw new TypeError("Invalid signal instance. Should be instance of internal AbortSignal implementation.");this.signal[I](e,t)}};if($){
const B=Object.getOwnPropertyDescriptors(G.prototype),U=function(){try{return Object.create($.prototype,B)}catch{const t=new $;return Object.defineProperties(t,B)}}();try{G.prototype=U}catch{const z=G;G=function(){const t=Object.getPrototypeOf(this),e=new z;return Object.setPrototypeOf(e,t),e},G.prototype=U}}G.prototype.constructor.name!==l&&Object.defineProperty(G.prototype.constructor,"name",{value:l,configurable:!0}),d(G.prototype,l),d(M.prototype,c),n=G,$?a&&(t=G,
p(globalThis,"AbortController",!0,t)):(t=G,e=M,p(globalThis,"AbortController",!0,t),p(globalThis,"AbortSignal",!0,e))}const _=n,g="AbortControllersGroup",y=f?Symbol("kIsAborted1"):"_kIsAborted1";export class AbortControllersGroup extends _{_controllers;_signals;_spreadAbortCall;_spreadOnAborted;__abortListener;[y]=!1;constructor(t,e,r=!0,o=!1){super();let n=null;this._controllers=t.filter(t=>{if(t){
if(!isAbortController(t))throw new TypeError('One member of "controllers" array is defined and not instanceof AbortController.');return t.signal.aborted&&(n=t.signal),!0}return!1}),this._signals=(e||[]).filter(t=>{if(t){if(!isAbortSignal(t))throw new TypeError('One member of "signals" array is defined and not instanceof AbortSignal.');return t.aborted&&(n=t),!0}return!1}),this._spreadAbortCall=r,this._spreadOnAborted=o;const i=this;this.__abortListener=function(){i._onAbort(this.reason)},
n?this._abort(n.reason,o,!0):this._sub()}destructor(){this.close()}close(){this._unsub(),this._controllers=[],this._signals=[]}abort(t){this._abort(t,this._spreadAbortCall,!1)}_abort(t,e,r){if(this[y]=!0,r||this._unsub(),super.abort(t),e)for(const t of this._controllers)t.abort(this.signal.reason);this._controllers=[],this._signals=[]}_onAbort=t=>{this[y]||(this._spreadOnAborted?this._abort(t,!0,!1):(this[y]=!0,this.close(),super.abort(t)))};_onAbortOwn=()=>{
this.signal.aborted&&this._onAbort(this.signal.reason)};_sub(){this.signal.addEventListener("abort",this._onAbortOwn);for(const t of this._controllers)t.signal.addEventListener("abort",this.__abortListener);for(const t of this._signals)t.addEventListener("abort",this.__abortListener)}_unsub(){this.signal.removeEventListener("abort",this._onAbortOwn);for(const t of this._controllers)t.signal.removeEventListener("abort",this.__abortListener)
;for(const t of this._signals)t.removeEventListener("abort",this.__abortListener)}}const E=AbortControllersGroup.prototype;E.constructor.name!==g&&Object.defineProperty(E.constructor,"name",{value:g,configurable:!0}),d(E,g);const m="AbortControllerProxy";export class AbortControllerProxy{_abortController;_emitter;_abortEventFilter;_closeEventFilter;_signal;_subscriptions=[];constructor(t){const{abortController:e,emitter:r,abortEventName:o,filter:n,closeEventName:i,closeEventFilter:s,signal:a}=t
;this._abortController=e,this._emitter=r,this._abortEventFilter="function"==typeof n?n:void 0,this._closeEventFilter="function"==typeof s?s:void 0,this._signal=a||void 0,this._sub(o,i,a)}destructor(){this.close()}close(){this._clear(!0)}_clear(t=!1){t&&this._unsub(),this._abortController=void 0,this._emitter=void 0,this._abortEventFilter=void 0,this._closeEventFilter=void 0,this._signal=void 0}_onAbortEvent=()=>{this.close()};_sub(t,e,r){const{_subscriptions:o,_abortController:n,_emitter:i}=this
;if(i&&n){r&&r.addEventListener("abort",this._onAbortEvent),Array.isArray(t)||(t=[t]);for(const e of t){const t=(...t)=>{this._onEmitterAbortEvent(e,...t)};o.push([e,1,t]),i.on(e,t)}if(e){Array.isArray(e)||(e=[e]);for(const t of e){const e=(...e)=>{this._onEmitterCloseEvent(t,...e)};o.push([t,2,e]),i.on(t,e)}}n.signal.addEventListener("abort",this._onAbortEvent)}}_unsub(){const{_subscriptions:t,_abortController:e,_emitter:r,_signal:o}=this;if(o&&o.removeEventListener("abort",this._onAbortEvent),
e&&e.signal.removeEventListener("abort",this._onAbortEvent),r)for(const[e,,o]of t)r.removeListener(e,o);t.length=0}_onEmitterAbortEvent(t,...e){const{_abortEventFilter:r,_emitter:o}=this;if(r&&!r.call(o,t,...e))return;const{0:n}=e;this._unsub();const{_abortController:i}=this;i&&i.abort(n),this._clear(!1)}_onEmitterCloseEvent(t,...e){const{_closeEventFilter:r,_emitter:o}=this;r&&!r.call(o,t,...e)||this._clear(!0)}}const A=AbortControllerProxy.prototype
;A.constructor.name!==m&&Object.defineProperty(A.constructor,"name",{value:m,configurable:!0}),d(A,m);const w="RemoteAbortController";export class RemoteAbortController extends _{_abortEventName;_emitter;[y]=!1;constructor(t,e){super(),this._emitter=t,this._abortEventName=e,this._sub()}destructor(){this.close()}close(){this._unsub(),this._emitter=void 0,this._abortEventName=""}abort(t){this._onAbort(t)}_onAbort=t=>{this[y]||(this[y]=!0,super.abort(t)),this._emitAbortEvent(t),this.close()}
;_onAbortOwn=()=>{this.signal.aborted&&this._onAbort(this.signal.reason)};_sub(){this.signal.addEventListener("abort",this._onAbortOwn)}_unsub(){this.signal.removeEventListener("abort",this._onAbortOwn)}_emitAbortEvent(t){const{_emitter:e,_abortEventName:r}=this;e&&r&&e.emit(r,t)}}const O=RemoteAbortController.prototype;function S(t,e){let r=t&&"object"==typeof t&&Object.getPrototypeOf(t)||void 0;for(;r;){if(r.constructor.name===e)return!0;r=Object.getPrototypeOf(r)}return!1}
O.constructor.name!==w&&Object.defineProperty(O.constructor,"name",{value:w,configurable:!0}),d(O,w);export function isAbortSignal(t){return t instanceof AbortSignal||S(t,c)}export function isAbortController(t){return t instanceof AbortController||S(t,l)}export function isAbortControllersGroup(t){return t instanceof AbortControllersGroup||S(t,g)}export const errorFabric=function(){if("undefined"!=typeof DOMException)try{
if(new DOMException("Aborted",b)instanceof DOMException)return function(t,e,r=0,o){const n=new DOMException(t,e);if(!n.stack){p(n,"stack",!1,new Error("-get-stack-").stack);const t=function(){return`DOMException [${this.name}]: ${this.message}\n${this.stack}`};p(n,"toString",!1,t),n[Symbol.for("nodejs.util.inspect.custom")]=t}return n.code!==r&&p(n,"code",!1,r),void 0!==o&&p(n,"cause",!1,o),n}}catch{}return function(t,e,r=0,o){const n=function(t){const{stack:e=""}=t;if(!function(t,e,r={}){
if(Object.isFrozen(t)||Object.isSealed(t))return!1;const o=Object.getOwnPropertyDescriptor(t,e);if(!o)return!0;if(r.isUseDefineProperty&&!o.configurable)return!1;return!!o.writable}(t,"stack"))return t;t.originalStack||(t.originalStack=t);return t.stack=e.split(/\n/).filter(t=>!/[/\\]AbortController\./.test(t)&&(!/[/\\]events\./.test(t)&&(!t.includes("node:internal/event_target")&&!t.includes("node:internal/abort_controller")&&"at new Promise (<anonymous>)"!==t))).join("\n"),t
}(new Error(t,void 0!==o?{cause:o}:void 0));return p(n,"name",!1,e||""),p(n,"code",!1,r),void 0!==o&&n.cause!==o&&p(n,"cause",!1,o),n}}();const C=20;let x,j;export function createAbortError(t,e){return void 0===x&&(x="undefined"!=typeof DOMException?C:"ABORT_ERR"),void 0===t&&(t=x),errorFabric("The operation was aborted",b,t,e)}export function isAbortError(t){if(t){if(t.code===C||"ABORT_ERR"===t.code)return!0
;if(t instanceof Error||"undefined"!=typeof DOMException&&t instanceof DOMException)return t.name===b}return!1}export const isAbortedError=isAbortError;export function isTimeoutError(t){if(t){if(23===t.code||"TIMEOUT_ERR"===t.code)return!0;if(t instanceof Error||"undefined"!=typeof DOMException&&t instanceof DOMException)return t.name===u}return!1}const L=t,k=e;if("function"!=typeof k.abort&&(k.abort=function(t){const e=new L;return e.abort(t),e.signal}),"function"!=typeof k.timeout){
const H=4294967295;k.timeout=function(t){if(t<0||0===t||t>H)throw new RangeError(`AbortSignal.timeout: The value of "delay" is out of range. It must be >= 1 && < ${H+1}. Received ${t}`);if(!Number.isFinite(t))throw new TypeError("AbortSignal.timeout: Argument 1 is not a finite value, so is out of range for unsigned long.");const e=new L;return setTimeout(()=>{var t,r;e.abort((void 0===j&&(j=23),void 0===t&&(t=j),errorFabric("The operation timed out.",u,t,r)))},t),e.signal}}
"function"!=typeof k.any&&(k.any=function(t){if(!t)throw new TypeError("AbortSignal.any: At least 1 argument required, but only 0 passed");if(!(Array.isArray(t)||t&&"object"==typeof t&&Symbol.iterator in t))throw new TypeError("AbortSignal.any: Argument 1 can't be converted to a sequence.");const e=new L,r=function(t){const r=this&&"reason"in this?this:t&&t.target?t.target:null;r||console.error("Invalid abortSignal inside AbortSignal.any~iterable[n].addEventListener~listener",this,t),
e.abort(r?.reason)};for(const o of t){if(!o||"object"!=typeof o)throw new TypeError("AbortSignal.any: Element of argument 1 is not an object.");if(!isAbortSignal(o))throw new TypeError("AbortSignal.any: Element of argument 1 does not implement interface AbortSignal.");if(o.aborted){e.abort(o.reason);break}o.addEventListener("abort",r,{signal:e.signal})}return e.signal}),"function"!=typeof k.prototype.throwIfAborted&&(k.prototype.throwIfAborted=function(){if(this.aborted)throw this.reason})
;export default L;export{L as AbortController};export{k as AbortSignal};export const hasNativeSupport=r;export const isFetchAbortable=i;
